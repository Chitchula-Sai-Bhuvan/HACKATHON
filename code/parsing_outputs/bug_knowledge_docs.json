[
  {
    "type": "BUG_KNOWLEDGE",
    "language": "C++",
    "bug_type": "unknown",
    "context": "mode for editing vectors at runtime",
    "buggy_code": "rdi.smartVec().vecEditMode(TA::VECD);\n\nRDI_BEGIN();\nrdi.smartVec()\n    .label(\"sLabel\").copyLabel(false).pin(A)\n    .writeData(\"rt\", 8, 0)\n    .execute();\n\nrdi.smartVec()\n    .label(\"sLabel\").copyLabel(false).pin(A)\n    .writeData(\"rt\", 8, 8)\n    .execute(); // \nRDI_END();",
    "correct_code": "rdi.smartVec().vecEditMode(TA::VTT);\n\nRDI_BEGIN();\nrdi.smartVec()\n    .label(\"sLabel\").copyLabel(false).pin(A)\n    .writeData(\"rt\", 8, 0)\n    .execute();\n\nrdi.smartVec()\n    .label(\"sLabel\").copyLabel(false).pin(A)\n    .writeData(\"rt\", 8, 8)\n    .execute(); // \nRDI_END();",
    "explanation": "Use only the VTT mode for editing vectors when rdi.smartVec().label().copyLabel() is\nused for the label",
    "bug_signature": "smartVec + execute + wrong order",
    "ast_context": {
      "calls": [
        {
          "method": "smartVec",
          "line": 1,
          "arguments": []
        },
        {
          "method": "vecEditMode",
          "line": 1,
          "arguments": [
            "TA::VECD"
          ]
        },
        {
          "method": "smartVec",
          "line": 4,
          "arguments": []
        },
        {
          "method": "label",
          "line": 5,
          "arguments": [
            "\"sLabel\""
          ]
        },
        {
          "method": "copyLabel",
          "line": 5,
          "arguments": [
            "false"
          ]
        },
        {
          "method": "pin",
          "line": 5,
          "arguments": [
            "A"
          ]
        },
        {
          "method": "writeData",
          "line": 6,
          "arguments": [
            "\"rt\"",
            "8",
            "0"
          ]
        },
        {
          "method": "execute",
          "line": 7,
          "arguments": []
        },
        {
          "method": "smartVec",
          "line": 9,
          "arguments": []
        },
        {
          "method": "label",
          "line": 10,
          "arguments": [
            "\"sLabel\""
          ]
        },
        {
          "method": "copyLabel",
          "line": 10,
          "arguments": [
            "false"
          ]
        },
        {
          "method": "pin",
          "line": 10,
          "arguments": [
            "A"
          ]
        },
        {
          "method": "writeData",
          "line": 11,
          "arguments": [
            "\"rt\"",
            "8",
            "8"
          ]
        },
        {
          "method": "execute",
          "line": 12,
          "arguments": []
        }
      ],
      "macros": []
    }
  },
  {
    "type": "BUG_KNOWLEDGE",
    "language": "C++",
    "bug_type": "unknown",
    "context": "rdi.port(TA::MULTI_PORT).func()\nThis function allows multi-port labels to be combined to form a new burst. It is used for\ndynamic mode in the func() class only.Multi-port burst with .port(TA::MULTI_PORT)",
    "buggy_code": "RDI_BEGIN();\nrdi.port(\"pt1\").dc().pin(\"dig2\").vForce(1 uA).burst();\nrdi.port(TA::MULTI_PORT).func().burst(\"MPBurst2\").burst(); // n\nrdi.port(\"pt2\").digCap().pin(\"dig1\").samples(8).execute();\nrdi.port(TA::MULTI_PORT).func().burst(\"MPBurst1\").burst();\nRDI_END();",
    "correct_code": "RDI_BEGIN();\nrdi.port(\"pt1\").dc().pin(\"dig\").vForce(1 V).execute();\nrdi.port(TA::MULTI_PORT).func().burst(\"MPBurst1\").execute(); // n\nrdi.port(\"pt2\").digCap().pin(\"dig2\").samples(8).execute();\nRDI_END();",
    "explanation": "BUG : Port name & pin config mismatch instead of execute it will burst twice",
    "bug_signature": "smartVec + execute + wrong order",
    "ast_context": {
      "calls": [
        {
          "method": "port",
          "line": 2,
          "arguments": [
            "\"pt1\""
          ]
        },
        {
          "method": "dc",
          "line": 2,
          "arguments": []
        },
        {
          "method": "pin",
          "line": 2,
          "arguments": [
            "\"dig2\""
          ]
        },
        {
          "method": "vForce",
          "line": 2,
          "arguments": [
            "1 uA"
          ]
        },
        {
          "method": "burst",
          "line": 2,
          "arguments": []
        },
        {
          "method": "port",
          "line": 3,
          "arguments": [
            "TA::MULTI_PORT"
          ]
        },
        {
          "method": "func",
          "line": 3,
          "arguments": []
        },
        {
          "method": "burst",
          "line": 3,
          "arguments": [
            "\"MPBurst2\""
          ]
        },
        {
          "method": "burst",
          "line": 3,
          "arguments": []
        },
        {
          "method": "port",
          "line": 4,
          "arguments": [
            "\"pt2\""
          ]
        },
        {
          "method": "digCap",
          "line": 4,
          "arguments": []
        },
        {
          "method": "pin",
          "line": 4,
          "arguments": [
            "\"dig1\""
          ]
        },
        {
          "method": "samples",
          "line": 4,
          "arguments": [
            "8"
          ]
        },
        {
          "method": "execute",
          "line": 4,
          "arguments": []
        },
        {
          "method": "port",
          "line": 5,
          "arguments": [
            "TA::MULTI_PORT"
          ]
        },
        {
          "method": "func",
          "line": 5,
          "arguments": []
        },
        {
          "method": "burst",
          "line": 5,
          "arguments": [
            "\"MPBurst1\""
          ]
        },
        {
          "method": "burst",
          "line": 5,
          "arguments": []
        }
      ],
      "macros": []
    }
  },
  {
    "type": "BUG_KNOWLEDGE",
    "language": "C++",
    "bug_type": "order violation",
    "context": "rdi.protocol().write()\nWrites a piece of data on a specified address at runtime",
    "buggy_code": "ARRAY_I write_data(2); // Define a variable for a dual-site test\nwrite_data[0]=0x1;\nwrite_data[1]=0x2;\nrdi.runTimeVal(\"data\",write_data); // Site data array\nRDI_END();\nrdi.protocol().pname(\"i2c\").write(0x4,\"data\").execute();\nRDI_BEGIN();",
    "correct_code": "ARRAY_I write_data(2);\nwrite_data[0]=0x1;\nwrite_data[1]=0x2;\nrdi.runTimeVal(\"data\",write_data); // Site data array\nRDI_BEGIN();\nrdi.protocol().pname(\"i2c\").write(0x4,\"data\").execute();\nRDI_END();",
    "explanation": "BUG : Replacing the lifecycle order \nand calling RDI_END before RDI_BEGIN inverts \nthe intended session/transaction scope and \nwill typically cause runtime failures or no-ops.",
    "bug_signature": "smartVec + execute + wrong order",
    "ast_context": {
      "calls": [
        {
          "method": "runTimeVal",
          "line": 4,
          "arguments": [
            "\"data\"",
            "write_data"
          ]
        },
        {
          "method": "protocol",
          "line": 6,
          "arguments": []
        },
        {
          "method": "pname",
          "line": 6,
          "arguments": [
            "\"i2c\""
          ]
        },
        {
          "method": "write",
          "line": 6,
          "arguments": [
            "0x4",
            "\"data\""
          ]
        },
        {
          "method": "execute",
          "line": 6,
          "arguments": []
        }
      ],
      "macros": []
    }
  },
  {
    "type": "BUG_KNOWLEDGE",
    "language": "C++",
    "bug_type": "unknown",
    "context": "Reads the actual measured humidity of the selected PMUX card from the hardware and\nstores it into a software cache.",
    "buggy_code": "RDI_BEGIN();\nrdi.pmux(4).module(\"02\").readHumanSeniority().execute();\nRDI_END();\nint hum = rdi.id(4).getHumanSeniority(\"02\");",
    "correct_code": "RDI_BEGIN();\nrdi.pmux(4).module(\"02\").readHumSensor().execute();\nRDI_END();\nint hum = rdi.id(4).getHumSensor (\"02\");",
    "explanation": "changed the function names",
    "bug_signature": "smartVec + execute + wrong order",
    "ast_context": {
      "calls": [
        {
          "method": "pmux",
          "line": 2,
          "arguments": [
            "4"
          ]
        },
        {
          "method": "module",
          "line": 2,
          "arguments": [
            "\"02\""
          ]
        },
        {
          "method": "readHumanSeniority",
          "line": 2,
          "arguments": []
        },
        {
          "method": "execute",
          "line": 2,
          "arguments": []
        },
        {
          "method": "id",
          "line": 4,
          "arguments": [
            "4"
          ]
        },
        {
          "method": "getHumanSeniority",
          "line": 4,
          "arguments": [
            "\"02\""
          ]
        }
      ],
      "macros": []
    }
  },
  {
    "type": "BUG_KNOWLEDGE",
    "language": "C++",
    "bug_type": "order violation",
    "context": "rdi.dc().addWaveform()\nAdds one or more waveforms in an execute() operation.\nThis function supports digital cards and DC Scale cards (PMU and DPS operating\nmodes).",
    "buggy_code": "anaWaveform wav1(\"wav1\"), wav2(\"wav2\"), wav3(\"wav3\");\nRDI_BEGIN();\nrdi.dc().pin(\"Pin1\").vForce().waveform(wav1)\n  .addWaveform(wav2)\n  .addWaveform(wav3, 2)      // Add \"wav3\" twice\n  .FS(250 /* kHz */).execute();\nrdi.dc().pin(\"Pin2\").vForce().waveform(wav1).repeat(2)\n  .iMeas()                   \n  .addWaveform(wav2, 3)      // Add \"wav2\" three times (group 2..4)\n  .FS(250 /* kHz */).read();\nRDI_END();",
    "correct_code": "anaWaveform wav1(\"wav1\"), wav2(\"wav2\"), wav3(\"wav3\");\nRDI_BEGIN();\n rdi.dc().pin(\"Pin1\").vForce().waveform(wav1)\n .addWaveform(wav2).addWaveform(wav3,2) // Add \"wav2\" once and\n .FS(250 kHz).execute();\n rdi.dc().pin(\"Pin2\").vForce().waveform (wav1).repeat(2)\n .addWaveform(wav2,3).iMeas() // Add \"wav2\" three times and me\n .FS(250 kHz).execute();\nRDI_END();",
    "explanation": "Measurement binding/order bug on Pin2.\nSpecifics: iMeas() is applied immediately after the first group (waveform + repeat), before the additional groups are appended then instead of execute it will read().",
    "bug_signature": "smartVec + execute + wrong order",
    "ast_context": {
      "calls": [
        {
          "method": "dc",
          "line": 3,
          "arguments": []
        },
        {
          "method": "pin",
          "line": 3,
          "arguments": [
            "\"Pin1\""
          ]
        },
        {
          "method": "vForce",
          "line": 3,
          "arguments": []
        },
        {
          "method": "waveform",
          "line": 3,
          "arguments": [
            "wav1"
          ]
        },
        {
          "method": "addWaveform",
          "line": 4,
          "arguments": [
            "wav2"
          ]
        },
        {
          "method": "addWaveform",
          "line": 5,
          "arguments": [
            "wav3",
            "2"
          ]
        },
        {
          "method": "FS",
          "line": 6,
          "arguments": [
            "250 /* kHz */"
          ]
        },
        {
          "method": "execute",
          "line": 6,
          "arguments": []
        },
        {
          "method": "dc",
          "line": 7,
          "arguments": []
        },
        {
          "method": "pin",
          "line": 7,
          "arguments": [
            "\"Pin2\""
          ]
        },
        {
          "method": "vForce",
          "line": 7,
          "arguments": []
        },
        {
          "method": "waveform",
          "line": 7,
          "arguments": [
            "wav1"
          ]
        },
        {
          "method": "repeat",
          "line": 7,
          "arguments": [
            "2"
          ]
        },
        {
          "method": "iMeas",
          "line": 8,
          "arguments": []
        },
        {
          "method": "addWaveform",
          "line": 9,
          "arguments": [
            "wav2",
            "3"
          ]
        },
        {
          "method": "FS",
          "line": 10,
          "arguments": [
            "250 /* kHz */"
          ]
        },
        {
          "method": "read",
          "line": 10,
          "arguments": []
        }
      ],
      "macros": []
    }
  },
  {
    "type": "BUG_KNOWLEDGE",
    "language": "C++",
    "bug_type": "order violation",
    "context": " burstUpload will help to reduce the result uploading time. The results of multiple smartVec read commands",
    "buggy_code": "// You can get a combined result of all readBit()/readData() inside\nON_FIRST_INVOCATION_BEGIN();\n\nrdi.smartVec().readMode(TA::EMAP); // TA::DIGCAP\n\nRDI_BEGIN();\nrdi.smartVec(\"id\").burstUpload().begin();\n\nrdi.smartVec(id1)\n    .pin(\"DATA2\").readBit(2, 2)\n    .execute();\n\nrdi.smartVec(id2)\n    .pin(\"DATA2\").readBit(4, 4)\n    .execute();\n\nrdi.smartVec(id3)\n    .pin(\"DATA4\").readData(8, 8)\n    .execute();\n\nrdi.smartVec(id4)\n    .pin(\"DATA4\").readData(8, 12)\n    .execute();\n\nrdi.burstUpload.smartVec().end();\nRDI_END();\n\nON_FIRST_INVOCATION_END();\n\nARRAY_I bitResult = rdi.id(\"id\").getReadBit(\"DATA2\");\nARRAY_LL dataResult = rdi.id(\"id\").getReadData(\"DATA4\");",
    "correct_code": "// You can get a combined result of all readBit()/readData() inside\nON_FIRST_INVOCATION_BEGIN();\n\nrdi.smartVec().readMode(TA::EMAP); // TA::DIGCAP\n\nRDI_BEGIN();\nrdi.smartVec(\"id\").burstUpload().begin();\n\nrdi.smartVec(id1)\n    .pin(\"DATA2\").readBit(2, 2)\n    .execute();\n\nrdi.smartVec(id2)\n    .pin(\"DATA2\").readBit(4, 4)\n    .execute();\n\nrdi.smartVec(id3)\n    .pin(\"DATA4\").readData(8, 8)\n    .execute();\n\nrdi.smartVec(id4)\n    .pin(\"DATA4\").readData(8, 12)\n    .execute();\n\nrdi.smartVec().burstUpload().end();\nRDI_END();\n\nON_FIRST_INVOCATION_END();\n\nARRAY_I bitResult = rdi.id(\"id\").getReadBit(\"DATA2\");\nARRAY_LL dataResult = rdi.id(\"id\").getReadData(\"DATA4\");",
    "explanation": "the order of function calling is smartVec().burstUpload()",
    "bug_signature": "smartVec + execute + wrong order",
    "ast_context": {
      "calls": [
        {
          "method": "smartVec",
          "line": 4,
          "arguments": []
        },
        {
          "method": "readMode",
          "line": 4,
          "arguments": [
            "TA::EMAP"
          ]
        },
        {
          "method": "smartVec",
          "line": 7,
          "arguments": [
            "\"id\""
          ]
        },
        {
          "method": "burstUpload",
          "line": 7,
          "arguments": []
        },
        {
          "method": "begin",
          "line": 7,
          "arguments": []
        },
        {
          "method": "smartVec",
          "line": 9,
          "arguments": [
            "id1"
          ]
        },
        {
          "method": "pin",
          "line": 10,
          "arguments": [
            "\"DATA2\""
          ]
        },
        {
          "method": "readBit",
          "line": 10,
          "arguments": [
            "2",
            "2"
          ]
        },
        {
          "method": "execute",
          "line": 11,
          "arguments": []
        },
        {
          "method": "smartVec",
          "line": 13,
          "arguments": [
            "id2"
          ]
        },
        {
          "method": "pin",
          "line": 14,
          "arguments": [
            "\"DATA2\""
          ]
        },
        {
          "method": "readBit",
          "line": 14,
          "arguments": [
            "4",
            "4"
          ]
        },
        {
          "method": "execute",
          "line": 15,
          "arguments": []
        },
        {
          "method": "smartVec",
          "line": 17,
          "arguments": [
            "id3"
          ]
        },
        {
          "method": "pin",
          "line": 18,
          "arguments": [
            "\"DATA4\""
          ]
        },
        {
          "method": "readData",
          "line": 18,
          "arguments": [
            "8",
            "8"
          ]
        },
        {
          "method": "execute",
          "line": 19,
          "arguments": []
        },
        {
          "method": "smartVec",
          "line": 21,
          "arguments": [
            "id4"
          ]
        },
        {
          "method": "pin",
          "line": 22,
          "arguments": [
            "\"DATA4\""
          ]
        },
        {
          "method": "readData",
          "line": 22,
          "arguments": [
            "8",
            "12"
          ]
        },
        {
          "method": "execute",
          "line": 23,
          "arguments": []
        },
        {
          "method": "smartVec",
          "line": 25,
          "arguments": []
        },
        {
          "method": "end",
          "line": 25,
          "arguments": []
        },
        {
          "method": "id",
          "line": 30,
          "arguments": [
            "\"id\""
          ]
        },
        {
          "method": "getReadBit",
          "line": 30,
          "arguments": [
            "\"DATA2\""
          ]
        },
        {
          "method": "id",
          "line": 31,
          "arguments": [
            "\"id\""
          ]
        },
        {
          "method": "getReadData",
          "line": 31,
          "arguments": [
            "\"DATA4\""
          ]
        }
      ],
      "macros": []
    }
  },
  {
    "type": "BUG_KNOWLEDGE",
    "language": "C++",
    "bug_type": "unknown",
    "context": "method order of arguments",
    "buggy_code": "rdi.alarm().pin(m_rMcd.sP_VS).enable(true);        //turn on VS alarm\n            //go back to default voltage\n            rdi.dc().pin(m_rMcd.sP_VS).vForce(31 V).vForceRange(30 V).iForceRange(50 mA).iClamp(50 mA, -50 mA)\n                    .pin(m_rMcd.sP_LIN).vForce(13.5 V).vForceRange(30 V).iForceRange(5 uA).iClamp(-5 uA, 5 uA)\n                    .execute();\n            rdi.wait(1 ms);",
    "correct_code": "rdi.alarm().pin(m_rMcd.sP_VS).enable(true);        //turn on VS alarm\n            //go back to default voltage\n            rdi.dc().pin(m_rMcd.sP_VS).vForce(31 V).vForceRange(30 V).iForceRange(50 mA).iClamp(-50 mA, 50 mA)\n                    .pin(m_rMcd.sP_LIN).vForce(13.5 V).vForceRange(30 V).iForceRange(5 uA).iClamp(-5 uA, 5 uA)\n                    .execute();\n            rdi.wait(1 ms);",
    "explanation": "iClamp low and high values are exchanged",
    "bug_signature": "smartVec + execute + wrong order",
    "ast_context": {
      "calls": [
        {
          "method": "alarm",
          "line": 1,
          "arguments": []
        },
        {
          "method": "pin",
          "line": 1,
          "arguments": [
            "m_rMcd.sP_VS"
          ]
        },
        {
          "method": "enable",
          "line": 1,
          "arguments": [
            "true"
          ]
        },
        {
          "method": "dc",
          "line": 3,
          "arguments": []
        },
        {
          "method": "pin",
          "line": 3,
          "arguments": [
            "m_rMcd.sP_VS"
          ]
        },
        {
          "method": "vForce",
          "line": 3,
          "arguments": [
            "31 V"
          ]
        },
        {
          "method": "vForceRange",
          "line": 3,
          "arguments": [
            "30 V"
          ]
        },
        {
          "method": "iForceRange",
          "line": 3,
          "arguments": [
            "50 mA"
          ]
        },
        {
          "method": "iClamp",
          "line": 3,
          "arguments": [
            "50 mA",
            "-50 mA"
          ]
        },
        {
          "method": "pin",
          "line": 4,
          "arguments": [
            "m_rMcd.sP_LIN"
          ]
        },
        {
          "method": "vForce",
          "line": 4,
          "arguments": [
            "13.5 V"
          ]
        },
        {
          "method": "vForceRange",
          "line": 4,
          "arguments": [
            "30 V"
          ]
        },
        {
          "method": "iForceRange",
          "line": 4,
          "arguments": [
            "5 uA"
          ]
        },
        {
          "method": "iClamp",
          "line": 4,
          "arguments": [
            "-5 uA",
            "5 uA"
          ]
        },
        {
          "method": "execute",
          "line": 5,
          "arguments": []
        },
        {
          "method": "wait",
          "line": 6,
          "arguments": [
            "1 ms"
          ]
        }
      ],
      "macros": []
    }
  },
  {
    "type": "BUG_KNOWLEDGE",
    "language": "C++",
    "bug_type": "unknown",
    "context": "rdi.func().burstRunTime()\nCreates an empty burst label and specifies the maximum number of labels to be\npatched.\nSmartRDI uses this function to generate an empty burst label and then applies the\nfirmware command SQPG to patch the burst content",
    "buggy_code": "vector<string> vec_port1;\nvec_port1.burst();\nvec_port1.push_back(\"label3\");\nvec_port2.push_back(\"label7\");\nvec_port1.push_forward(\"label25\");\nvec_port2.push_forward(\"label31\");\nrdi.runTimeVal(\"rt\",vec_port2); // The label to be patched into the\nRDI_BEGIN();\nrdi.port(\"A\").func(\"idd\").burstRunTime(\"rt\",200).execute();\nRDI_END();\nARRAY_I ary = rdi.id(\"idd\").getMultiPassFail();",
    "correct_code": "vector<string> vec_port1;\nvec_port1.clear();\nvec_port1.push_back(\"label3\");\nvec_port1.push_back(\"label7\");\nvec_port1.push_back(\"label25\");\nvec_port1.push_back(\"label31\");\nrdi.runTimeVal(\"rt\",vec_port1); // The label to be patched into the\nRDI_BEGIN();\nrdi.port(\"A\").func(\"id\").burstRunTime(\"rt\",200).execute();\nRDI_END();\nARRAY_I ary = rdi.id(\"id\").getMultiPassFail();",
    "explanation": "BUG : Logical api changes (push_forward >> push_back , port name at intaialization is different from runTimeVAL & synatax of id changed to idd )",
    "bug_signature": "smartVec + execute + wrong order",
    "ast_context": {
      "calls": [
        {
          "method": "burst",
          "line": 2,
          "arguments": []
        },
        {
          "method": "push_back",
          "line": 3,
          "arguments": [
            "\"label3\""
          ]
        },
        {
          "method": "push_back",
          "line": 4,
          "arguments": [
            "\"label7\""
          ]
        },
        {
          "method": "push_forward",
          "line": 5,
          "arguments": [
            "\"label25\""
          ]
        },
        {
          "method": "push_forward",
          "line": 6,
          "arguments": [
            "\"label31\""
          ]
        },
        {
          "method": "runTimeVal",
          "line": 7,
          "arguments": [
            "\"rt\"",
            "vec_port2"
          ]
        },
        {
          "method": "port",
          "line": 9,
          "arguments": [
            "\"A\""
          ]
        },
        {
          "method": "func",
          "line": 9,
          "arguments": [
            "\"idd\""
          ]
        },
        {
          "method": "burstRunTime",
          "line": 9,
          "arguments": [
            "\"rt\"",
            "200"
          ]
        },
        {
          "method": "execute",
          "line": 9,
          "arguments": []
        },
        {
          "method": "id",
          "line": 11,
          "arguments": [
            "\"idd\""
          ]
        },
        {
          "method": "getMultiPassFail",
          "line": 11,
          "arguments": []
        }
      ],
      "macros": []
    }
  },
  {
    "type": "BUG_KNOWLEDGE",
    "language": "C++",
    "bug_type": "unknown",
    "context": "getting the first fail vector.",
    "buggy_code": "RDI_BEGIN();\nrdi.emap(\"a\")\n    .label(\"label2\").pin(\"pB\")\n    .FFV(10)\n    .execute();\nRDI_END();\n\nint iffv = rdi.id(\"a\").getFFC();",
    "correct_code": "RDI_BEGIN();\nrdi.emap(\"a\")\n    .label(\"label2\").pin(\"pB\")\n    .FFV(10)\n    .execute();\nRDI_END();\n\nint iffv = rdi.id(\"a\").getFFV();",
    "explanation": "to get first filed vector the function used is getFFV()",
    "bug_signature": "smartVec + execute + wrong order",
    "ast_context": {
      "calls": [
        {
          "method": "emap",
          "line": 2,
          "arguments": [
            "\"a\""
          ]
        },
        {
          "method": "label",
          "line": 3,
          "arguments": [
            "\"label2\""
          ]
        },
        {
          "method": "pin",
          "line": 3,
          "arguments": [
            "\"pB\""
          ]
        },
        {
          "method": "FFV",
          "line": 4,
          "arguments": [
            "10"
          ]
        },
        {
          "method": "execute",
          "line": 5,
          "arguments": []
        },
        {
          "method": "id",
          "line": 8,
          "arguments": [
            "\"a\""
          ]
        },
        {
          "method": "getFFC",
          "line": 8,
          "arguments": []
        }
      ],
      "macros": []
    }
  },
  {
    "type": "BUG_KNOWLEDGE",
    "language": "C++",
    "bug_type": "config mismatch",
    "context": "rdi.dc().iMeasRange()\nSpecifies a current measurement range.SmartRDI will check the time between iMeasRange() and the next event on the pin. ",
    "buggy_code": "RDI_BEGIN();\nrdi.dc().pin(\"DPS_1,DPS_2\").imeasRange(100 uA);\nrdi.dc().pin(\"DPS_1,DPS_2\").vForce(0.01 V);\nrdi.wait(3 ms);\nrdi.dc(\"im1\").pin(\"DPS_0,DPS_1\").imeas().write();\nRDI_END();",
    "correct_code": "RDI_BEGIN();\nrdi.dc().pin(\"DPS_1,DPS_2\").iMeasRange(100 uA);\nrdi.dc().pin(\"DPS_1,DPS_2\").vForce(0.01 V);\nrdi.wait(3 ms);\nrdi.dc(\"im1\").pin(\"DPS_1,DPS_2\").iMeas().execute();\nRDI_END();",
    "explanation": "BUGS:\n- Pin list changed to \"DPS_0,DPS_1\" (mismatch with configured pins)\n- Method name changed to \"imeas()\" (incorrect casing/API)\n- Operation changed from \"execute()\" to \"write()\" (wrong semantics in DC measurement chain)",
    "bug_signature": "unknown pattern",
    "ast_context": {
      "calls": [
        {
          "method": "dc",
          "line": 2,
          "arguments": []
        },
        {
          "method": "pin",
          "line": 2,
          "arguments": [
            "\"DPS_1",
            "DPS_2\""
          ]
        },
        {
          "method": "imeasRange",
          "line": 2,
          "arguments": [
            "100 uA"
          ]
        },
        {
          "method": "dc",
          "line": 3,
          "arguments": []
        },
        {
          "method": "pin",
          "line": 3,
          "arguments": [
            "\"DPS_1",
            "DPS_2\""
          ]
        },
        {
          "method": "vForce",
          "line": 3,
          "arguments": [
            "0.01 V"
          ]
        },
        {
          "method": "wait",
          "line": 4,
          "arguments": [
            "3 ms"
          ]
        },
        {
          "method": "dc",
          "line": 5,
          "arguments": [
            "\"im1\""
          ]
        },
        {
          "method": "pin",
          "line": 5,
          "arguments": [
            "\"DPS_0",
            "DPS_1\""
          ]
        },
        {
          "method": "imeas",
          "line": 5,
          "arguments": []
        },
        {
          "method": "write",
          "line": 5,
          "arguments": []
        }
      ],
      "macros": []
    }
  },
  {
    "type": "BUG_KNOWLEDGE",
    "language": "C++",
    "bug_type": "unknown",
    "context": "Generating a new digital capture pattern\nwith SmartRDI.Digital capture without hidden upload",
    "buggy_code": "ON_FIRST_INVOCATION_BEGIN();\nRDI_BEGIN();\nrdi.digCap(\"cap\").pin(\"D0\").samples(100).initDiscard(10).interS;\nRDI_END();\nON_FIRST_INVOCATION_END();\nconst ARRAY_I& aiData = rdi.id(\"cap\").getVector(\"DO\");",
    "correct_code": "ON_FIRST_INVOCATION_BEGIN();\nRDI_BEGIN();\nrdi.digCap(\"cap\").pin(\"DO\").samples(100).initDiscard(10).interS\nRDI_END( );\nON_FIRST_INVOCATION_END();\nconst ARRAY_I& aiData = rdi.id(\"cap\").getVector(\"DO\");",
    "explanation": "BUG: Pin name typo \u2014 using \"D0\" (digit zero) instead of \"DO\" (letter O).\nThis will capture data on pin \"D0\", but later we try to read from \"DO\".\n\nLater, we attempt to retrieve the captured vector from pin \"DO\" (letter O).\nBecause the capture used \"D0\", this lookup will not match and may return empty or error.",
    "bug_signature": "unknown pattern",
    "ast_context": {
      "calls": [
        {
          "method": "digCap",
          "line": 3,
          "arguments": [
            "\"cap\""
          ]
        },
        {
          "method": "pin",
          "line": 3,
          "arguments": [
            "\"D0\""
          ]
        },
        {
          "method": "samples",
          "line": 3,
          "arguments": [
            "100"
          ]
        },
        {
          "method": "initDiscard",
          "line": 3,
          "arguments": [
            "10"
          ]
        },
        {
          "method": "id",
          "line": 6,
          "arguments": [
            "\"cap\""
          ]
        },
        {
          "method": "getVector",
          "line": 6,
          "arguments": [
            "\"DO\""
          ]
        }
      ],
      "macros": []
    }
  },
  {
    "type": "BUG_KNOWLEDGE",
    "language": "C++",
    "bug_type": "unknown",
    "context": "Getting alarm DC results on specific pins",
    "buggy_code": "RDI_BEGIN();\n...\nrdi.dc(\"a\").pin(\"dig\").iForce(0).vMeas().execute(); \n...\nRDI_END();\n\ndouble dVal = rdi.id(\"a\").getAlarmValue();\nARRAY_D aryVal = rdi.id(\"a\").getAlarmBurstValue(\"AVI\");",
    "correct_code": "RDI_BEGIN();\n...\nrdi.dc(\"a\").pin(\"dig\").iForce(0).vMeas().execute(); \n...\nRDI_END();\n\ndouble dVal = rdi.id(\"a\").getAlarmValue(\"AVI\");\nARRAY_D aryVal = rdi.id(\"a\").getAlarmBurstValue(\"AVI\");",
    "explanation": "here getAlarmValue() takes a parameter sPin ",
    "bug_signature": "smartVec + execute + wrong order",
    "ast_context": {
      "calls": [
        {
          "method": "dc",
          "line": 3,
          "arguments": [
            "\"a\""
          ]
        },
        {
          "method": "pin",
          "line": 3,
          "arguments": [
            "\"dig\""
          ]
        },
        {
          "method": "iForce",
          "line": 3,
          "arguments": [
            "0"
          ]
        },
        {
          "method": "vMeas",
          "line": 3,
          "arguments": []
        },
        {
          "method": "execute",
          "line": 3,
          "arguments": []
        },
        {
          "method": "id",
          "line": 7,
          "arguments": [
            "\"a\""
          ]
        },
        {
          "method": "getAlarmValue",
          "line": 7,
          "arguments": []
        },
        {
          "method": "id",
          "line": 8,
          "arguments": [
            "\"a\""
          ]
        },
        {
          "method": "getAlarmBurstValue",
          "line": 8,
          "arguments": [
            "\"AVI\""
          ]
        }
      ],
      "macros": []
    }
  },
  {
    "type": "BUG_KNOWLEDGE",
    "language": "C++",
    "bug_type": "unknown",
    "context": "System-reserved waiting in cogo",
    "buggy_code": "rdi.cogo().node(\"this\").passNode(\"id1\").failNode(\"id2\").begin();\nrdi.cogo().wait(100 us);\nrdi.cogo().end().end();",
    "correct_code": "rdi.cogo().node(\"this\").passNode(\"id1\").failNode(\"id2\").begin();\nrdi.cogo().wait(100 us);\nrdi.cogo().node().end();",
    "explanation": "Used same function twice",
    "bug_signature": "unknown pattern",
    "ast_context": {
      "calls": [
        {
          "method": "cogo",
          "line": 1,
          "arguments": []
        },
        {
          "method": "node",
          "line": 1,
          "arguments": [
            "\"this\""
          ]
        },
        {
          "method": "passNode",
          "line": 1,
          "arguments": [
            "\"id1\""
          ]
        },
        {
          "method": "failNode",
          "line": 1,
          "arguments": [
            "\"id2\""
          ]
        },
        {
          "method": "begin",
          "line": 1,
          "arguments": []
        },
        {
          "method": "cogo",
          "line": 2,
          "arguments": []
        },
        {
          "method": "wait",
          "line": 2,
          "arguments": [
            "100 us"
          ]
        },
        {
          "method": "cogo",
          "line": 3,
          "arguments": []
        },
        {
          "method": "end",
          "line": 3,
          "arguments": []
        },
        {
          "method": "end",
          "line": 3,
          "arguments": []
        }
      ],
      "macros": []
    }
  },
  {
    "type": "BUG_KNOWLEDGE",
    "language": "C++",
    "bug_type": "unknown",
    "context": "Hidden upload in CCTestMethod_ISR\nThe code example below describes how to use the hidden upload feature in",
    "buggy_code": " SMC_BackgroundProcessing()\n{\nrdi.id(\"cap\").getVesjkctor();\nrdi.id(\"idd\").getVslkhalue();\nrdi.id(\"dgr\").getWlkjnaveform();\n}",
    "correct_code": " SMC_BackgroundProcessing()\n{\nrdi.id(\"cap\").getVector();\nrdi.id(\"idd\").getValue();\nrdi.id(\"dgr\").getWaveform();\n}",
    "explanation": "Changed all the function names to random strings",
    "bug_signature": "unknown pattern",
    "ast_context": {
      "calls": [
        {
          "method": "id",
          "line": 3,
          "arguments": [
            "\"cap\""
          ]
        },
        {
          "method": "getVesjkctor",
          "line": 3,
          "arguments": []
        },
        {
          "method": "id",
          "line": 4,
          "arguments": [
            "\"idd\""
          ]
        },
        {
          "method": "getVslkhalue",
          "line": 4,
          "arguments": []
        },
        {
          "method": "id",
          "line": 5,
          "arguments": [
            "\"dgr\""
          ]
        },
        {
          "method": "getWlkjnaveform",
          "line": 5,
          "arguments": []
        }
      ],
      "macros": []
    }
  },
  {
    "type": "BUG_KNOWLEDGE",
    "language": "C++",
    "bug_type": "unknown",
    "context": "reading the temperature alarm threshold of the selected PMUX card",
    "buggy_code": "RDI_BEGIN();\nrdi.pmux(1)\n    .module(\"02\").readTempThresh(70)\n    .execute();\nRDI_END();\n\nint tempTh = rdi.id(1).getTempThresh(\"02\");",
    "correct_code": "RDI_BEGIN();\nrdi.pmux(1)\n    .module(\"02\").readTempThresh()\n    .execute();\nRDI_END();\n\nint tempTh = rdi.id(1).getTempThresh(\"02\");",
    "explanation": "there are no parameters for readTempThresh function",
    "bug_signature": "smartVec + execute + wrong order",
    "ast_context": {
      "calls": [
        {
          "method": "pmux",
          "line": 2,
          "arguments": [
            "1"
          ]
        },
        {
          "method": "module",
          "line": 3,
          "arguments": [
            "\"02\""
          ]
        },
        {
          "method": "readTempThresh",
          "line": 3,
          "arguments": [
            "70"
          ]
        },
        {
          "method": "execute",
          "line": 4,
          "arguments": []
        },
        {
          "method": "id",
          "line": 7,
          "arguments": [
            "1"
          ]
        },
        {
          "method": "getTempThresh",
          "line": 7,
          "arguments": [
            "\"02\""
          ]
        }
      ],
      "macros": []
    }
  },
  {
    "type": "BUG_KNOWLEDGE",
    "language": "C++",
    "bug_type": "order violation",
    "context": "Retrieves the status of a pmux switch in both online mode and offline mode.rdi.route().retrievePmuxPinStatus()",
    "buggy_code": "RDI_BEGIN();\nrdi.route().pin(\"P0x01F1\").setOff().execute();\nrdi.route().pin(\"P0x07F1\").setOn().execute();\nrdi.route().retrievePmuxPinStatus(\"P0x01F1\");\nrdi.route().retrievePmuxPinStatus(\"P0x07F1\");\nrdi.route().retrievePmuxPinStatus(\"P0x08F1\");\nRDI_END();",
    "correct_code": "RDI_BEGIN();\nrdi.route().pin(\"P0x01F1\").setOff().execute();\nrdi.route().pin(\"P0x07F1\").setOn().execute();\nRDI_END();\nrdi.route().retrievePmuxPinStatus(\"P0x01F1\");\n// Result on site 1 is {0}\nrdi.route().retrievePmuxPinStatus(\"P0x07F1\");\n// Result on site 1 is {1,1}, for the Link pin",
    "explanation": "Bug: Retrieving status before execute() completion and without proper synchronization\n- Result on site 1 might be inconsistent or stale\n- Result on site 1 might show previous state instead of {1,1}\n- Missing error handling for invalid pin addresses\n- Incorrect Begin & End",
    "bug_signature": "smartVec + execute + wrong order",
    "ast_context": {
      "calls": [
        {
          "method": "route",
          "line": 2,
          "arguments": []
        },
        {
          "method": "pin",
          "line": 2,
          "arguments": [
            "\"P0x01F1\""
          ]
        },
        {
          "method": "setOff",
          "line": 2,
          "arguments": []
        },
        {
          "method": "execute",
          "line": 2,
          "arguments": []
        },
        {
          "method": "route",
          "line": 3,
          "arguments": []
        },
        {
          "method": "pin",
          "line": 3,
          "arguments": [
            "\"P0x07F1\""
          ]
        },
        {
          "method": "setOn",
          "line": 3,
          "arguments": []
        },
        {
          "method": "execute",
          "line": 3,
          "arguments": []
        },
        {
          "method": "route",
          "line": 4,
          "arguments": []
        },
        {
          "method": "retrievePmuxPinStatus",
          "line": 4,
          "arguments": [
            "\"P0x01F1\""
          ]
        },
        {
          "method": "route",
          "line": 5,
          "arguments": []
        },
        {
          "method": "retrievePmuxPinStatus",
          "line": 5,
          "arguments": [
            "\"P0x07F1\""
          ]
        },
        {
          "method": "route",
          "line": 6,
          "arguments": []
        },
        {
          "method": "retrievePmuxPinStatus",
          "line": 6,
          "arguments": [
            "\"P0x08F1\""
          ]
        }
      ],
      "macros": []
    }
  },
  {
    "type": "BUG_KNOWLEDGE",
    "language": "C++",
    "bug_type": "unknown",
    "context": "Specification of AVI64",
    "buggy_code": "\trdi.alarm().pin(m_rMcd.sP_VS).enable(true);        //turn on VS alarm\n            //go back to default voltage\n            rdi.dc().pin(m_rMcd.sP_VS).vForce(13.5 V).vForceRange(35 V).iForceRange(50 mA).iClamp(-50 mA, 50 mA)\n                    .pin(m_rMcd.sP_LIN).vForce(13.5 V).vForceRange(30 V).iForceRange(5 uA).iClamp(-5 uA, 5 uA)\n                    .execute();\n            rdi.wait(1 ms);",
    "correct_code": "\trdi.alarm().pin(m_rMcd.sP_VS).enable(true);        //turn on VS alarm\n            //go back to default voltage\n            rdi.dc().pin(m_rMcd.sP_VS).vForce(13.5 V).vForceRange(30 V).iForceRange(50 mA).iClamp(-50 mA, 50 mA)\n                    .pin(m_rMcd.sP_LIN).vForce(13.5 V).vForceRange(30 V).iForceRange(5 uA).iClamp(-5 uA, 5 uA)\n                    .execute();\n            rdi.wait(1 ms);",
    "explanation": "vForce set to 35V which is not one of the allowed range according to the above documentation for an assumed AVI64",
    "bug_signature": "smartVec + execute + wrong order",
    "ast_context": {
      "calls": [
        {
          "method": "alarm",
          "line": 1,
          "arguments": []
        },
        {
          "method": "pin",
          "line": 1,
          "arguments": [
            "m_rMcd.sP_VS"
          ]
        },
        {
          "method": "enable",
          "line": 1,
          "arguments": [
            "true"
          ]
        },
        {
          "method": "dc",
          "line": 3,
          "arguments": []
        },
        {
          "method": "pin",
          "line": 3,
          "arguments": [
            "m_rMcd.sP_VS"
          ]
        },
        {
          "method": "vForce",
          "line": 3,
          "arguments": [
            "13.5 V"
          ]
        },
        {
          "method": "vForceRange",
          "line": 3,
          "arguments": [
            "35 V"
          ]
        },
        {
          "method": "iForceRange",
          "line": 3,
          "arguments": [
            "50 mA"
          ]
        },
        {
          "method": "iClamp",
          "line": 3,
          "arguments": [
            "-50 mA",
            "50 mA"
          ]
        },
        {
          "method": "pin",
          "line": 4,
          "arguments": [
            "m_rMcd.sP_LIN"
          ]
        },
        {
          "method": "vForce",
          "line": 4,
          "arguments": [
            "13.5 V"
          ]
        },
        {
          "method": "vForceRange",
          "line": 4,
          "arguments": [
            "30 V"
          ]
        },
        {
          "method": "iForceRange",
          "line": 4,
          "arguments": [
            "5 uA"
          ]
        },
        {
          "method": "iClamp",
          "line": 4,
          "arguments": [
            "-5 uA",
            "5 uA"
          ]
        },
        {
          "method": "execute",
          "line": 5,
          "arguments": []
        },
        {
          "method": "wait",
          "line": 6,
          "arguments": [
            "1 ms"
          ]
        }
      ],
      "macros": []
    }
  },
  {
    "type": "BUG_KNOWLEDGE",
    "language": "C++",
    "bug_type": "unknown",
    "context": "local control over the \"burst site upload\" capacity for digital capture results",
    "buggy_code": "rdi.digCapBurstSiteUpload(false);\n\nRDI_BEGIN();\nrdi.digCap(1)\n    .pin(\"DATA1\").samples(9216)\n    .execute();\nRDI_END();",
    "correct_code": "rdi.digCapBurstSiteUpload(true);\n\nRDI_BEGIN();\nrdi.digCap(1)\n    .pin(\"DATA1\").samples(8192)\n    .execute();\nRDI_END();",
    "explanation": " rdi.digCapBurstSiteUpload(true) should be set to true for uploads and as per documentation the max sample number can be 8192",
    "bug_signature": "smartVec + execute + wrong order",
    "ast_context": {
      "calls": [
        {
          "method": "digCapBurstSiteUpload",
          "line": 1,
          "arguments": [
            "false"
          ]
        },
        {
          "method": "digCap",
          "line": 4,
          "arguments": [
            "1"
          ]
        },
        {
          "method": "pin",
          "line": 5,
          "arguments": [
            "\"DATA1\""
          ]
        },
        {
          "method": "samples",
          "line": 5,
          "arguments": [
            "9216"
          ]
        },
        {
          "method": "execute",
          "line": 6,
          "arguments": []
        }
      ],
      "macros": []
    }
  },
  {
    "type": "BUG_KNOWLEDGE",
    "language": "C++",
    "bug_type": "unknown",
    "context": "Specifies the number of samples used to do the averaging when the measurement\ninstrument is board ADC. The result of the measurement is averaged.\nFor accuracy considerations, refer to member function number of samples() of API\nPPMU_PIN_MEASURE.",
    "buggy_code": "RDI_BEGIN();\nrdi.dc().pin(\"dig1\").vForce(1).iMeans().iRange(2 mAh).execute(); //\nrdi.dc().pin(\"dig2\").iForce(1 uA).vMeans().execute(); // average =\nRDI_END();",
    "correct_code": "RDI_BEGIN();\nrdi.dc().pin(\"dig1\").vForce(1).iMeas().iRange(2 mA).execute(); //\nrdi.dc().pin(\"dig2\").iForce(1 uA).vMeas().execute(); // average =\nRDI_END();",
    "explanation": "Changed the argument unit and name",
    "bug_signature": "smartVec + execute + wrong order",
    "ast_context": {
      "calls": [
        {
          "method": "dc",
          "line": 2,
          "arguments": []
        },
        {
          "method": "pin",
          "line": 2,
          "arguments": [
            "\"dig1\""
          ]
        },
        {
          "method": "vForce",
          "line": 2,
          "arguments": [
            "1"
          ]
        },
        {
          "method": "iMeans",
          "line": 2,
          "arguments": []
        },
        {
          "method": "iRange",
          "line": 2,
          "arguments": [
            "2 mAh"
          ]
        },
        {
          "method": "execute",
          "line": 2,
          "arguments": []
        },
        {
          "method": "dc",
          "line": 3,
          "arguments": []
        },
        {
          "method": "pin",
          "line": 3,
          "arguments": [
            "\"dig2\""
          ]
        },
        {
          "method": "iForce",
          "line": 3,
          "arguments": [
            "1 uA"
          ]
        },
        {
          "method": "vMeans",
          "line": 3,
          "arguments": []
        },
        {
          "method": "execute",
          "line": 3,
          "arguments": []
        }
      ],
      "macros": []
    }
  },
  {
    "type": "BUG_KNOWLEDGE",
    "language": "C++",
    "bug_type": "API misuse",
    "context": "Specification of AVI64",
    "buggy_code": "//rdi.alarm().pin(m_rMcd.sP_MON).enable(true);    //turn on MON alarm\nrdi.alarm().pin(m_rMcd.sP_VS).enable(true);        //turn on VS alarm\n            //go back to default voltage\n            rdi.dc().pin(m_rMcd.sP_VS).vForce(31 V).vForceRange(30 V).iForceRange(50 mA).iClamp(-50 mA, 50 mA)\n                    .pin(m_rMcd.sP_LIN).vForce(13.5 V).vForceRange(30 V).iForceRange(5 uA).iClamp(-5 uA, 5 uA)\n                    .execute();\n            rdi.wait(1 ms);",
    "correct_code": "//rdi.alarm().pin(m_rMcd.sP_MON).enable(true);    //turn on MON alarm\nrdi.alarm().pin(m_rMcd.sP_VS).enable(true);        //turn on VS alarm\n            //go back to default voltage\n            rdi.dc().pin(m_rMcd.sP_VS).vForce(30 V).vForceRange(30 V).iForceRange(50 mA).iClamp(-50 mA, 50 mA)\n                    .pin(m_rMcd.sP_LIN).vForce(13.5 V).vForceRange(30 V).iForceRange(5 uA).iClamp(-5 uA, 5 uA)\n                    .execute();\n            rdi.wait(1 ms);",
    "explanation": "The key sentence in the manual is: \"The programmed force or clamp value must always match to the selected range. Violating this rule may lead to a range overflow warning.\"\nvForce set to 31V which is above range, applies for AVI64/FVI16. This is configured somewhere else. For the sake of easiness we could tell the prompt we deal with an AVI64",
    "bug_signature": "smartVec + execute + wrong order",
    "ast_context": {
      "calls": [
        {
          "method": "alarm",
          "line": 1,
          "arguments": []
        },
        {
          "method": "pin",
          "line": 1,
          "arguments": [
            "m_rMcd.sP_MON"
          ]
        },
        {
          "method": "enable",
          "line": 1,
          "arguments": [
            "true"
          ]
        },
        {
          "method": "alarm",
          "line": 2,
          "arguments": []
        },
        {
          "method": "pin",
          "line": 2,
          "arguments": [
            "m_rMcd.sP_VS"
          ]
        },
        {
          "method": "enable",
          "line": 2,
          "arguments": [
            "true"
          ]
        },
        {
          "method": "dc",
          "line": 4,
          "arguments": []
        },
        {
          "method": "pin",
          "line": 4,
          "arguments": [
            "m_rMcd.sP_VS"
          ]
        },
        {
          "method": "vForce",
          "line": 4,
          "arguments": [
            "31 V"
          ]
        },
        {
          "method": "vForceRange",
          "line": 4,
          "arguments": [
            "30 V"
          ]
        },
        {
          "method": "iForceRange",
          "line": 4,
          "arguments": [
            "50 mA"
          ]
        },
        {
          "method": "iClamp",
          "line": 4,
          "arguments": [
            "-50 mA",
            "50 mA"
          ]
        },
        {
          "method": "pin",
          "line": 5,
          "arguments": [
            "m_rMcd.sP_LIN"
          ]
        },
        {
          "method": "vForce",
          "line": 5,
          "arguments": [
            "13.5 V"
          ]
        },
        {
          "method": "vForceRange",
          "line": 5,
          "arguments": [
            "30 V"
          ]
        },
        {
          "method": "iForceRange",
          "line": 5,
          "arguments": [
            "5 uA"
          ]
        },
        {
          "method": "iClamp",
          "line": 5,
          "arguments": [
            "-5 uA",
            "5 uA"
          ]
        },
        {
          "method": "execute",
          "line": 6,
          "arguments": []
        },
        {
          "method": "wait",
          "line": 7,
          "arguments": [
            "1 ms"
          ]
        }
      ],
      "macros": []
    }
  }
]
